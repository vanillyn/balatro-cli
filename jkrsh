#!/usr/bin/env bash
#                           ---.
#                         -,JOOOJ=.
#                       -,OKKKKOEEK:
#                      :OKKKKKKJrrrJ
#                     :OKKKKKKKO,O=
#             -=JJJJ/=OKKKKKKKKKJ:=JJJJ=-             jkrsh (joker shell)
#            /ERRRRRREKKKKKKKKKKKERRRRRRE/            a tool by vanillyn
#           /EREKERREKKKKKOKOKKKKKERREERRE/
#          .ORO=..JEKKKKOKEEEKOKKKKEJ..=KRO.
#          Oekj-  /KKKRkerrrrrekRKKK=  :okeO
#          /oeK- :OKKEjokkrrrkkoREKKO: -Eeo/          modifies and runs Balatro on Linux natively
#            .   =OEoojE[JOKER]EjkeKJ:   .
#                .Jjkrrrrrrrrrrrrrro,.
#                =jejKRjkojjjokjRKoro:
#                 =EkoKOKjooojKOKkeR=
#                   JekEKERRREKRerJ
#              .--//JjerekjjjkerroJ,,/:.
#           -=,JOOEERokookeerkoojoojREKOJ=:
#         .,JOEEjjoooRKOOEjjooEOORjjooojRKO/.
#         /JJOKRjoojOJOEREKOKjojOJKjjjojKOKK,
#         /JJJ,JKREOJKKOJJ,,,JJERKJORRO,,JJO=
#         =OO,/-.=JJJKJ,J,:-:,,,OEJJJ:.-/,,=
#         =OO=   =JOOJJJ/.   ./JJJOOJ:   =/=
#                -,JJJ/-       -/JJO,-
#                :,,,:           :JKO:
#                 ---             -::

CONF="$HOME/.config/balatro/config"
CONF_DIR="$HOME/.config/balatro"
REPO_DIR="$CONF_DIR/repos"
mkdir -p $REPO_DIR

LOCKFILE="/tmp/balatro.lock"
LAUNCH=("native" "wine" "steam")
ver="v0.1"
ARGS=()


if [[ -f "$LOCKFILE" ]]; then
    echo "another instance is already running. exiting."
    exit 1
fi

# --- Configs
# Make config if missing

mkconf() {
    mkdir -p "$(dirname "$CONF")"
    mkdir -p "$(dirname "$CONF")/mods"

    cat <<EOF >"$CONF"
# config file for balatro-cli

# the path that contains Balatro.exe or balatro-native
GAME_PATH="/usr/bin/balatro-native"

# the path that mods will be downloaded to
DOWNLOAD_DIR="\$HOME/.config/balatro/mods"

# the path that lovely will load mods from
MODS_DIR="\$HOME/.config/love"

# the path that contains your Balatro saves and mod directory
USER_DIR="\$HOME/.local/share/love/Balatro"

# the path to your love binary ("love" or "/usr/bin/love" by default)
LOVE_BIN="love"

# the path to your wine binary ("wine" or "/usr/bin/wine" by default)
WINE_BIN="wine"

# the wineprefix used for running Balatro with wine
WINEPREFIX="/opt/Balatro"

# the mode that balatro will be launched in by default ("native", "steam", or "wine")
MODE="native"

# if set to 1, mods are not copied to the mod directory
NOINSTALL="0"

# if set to 1, debug logs are sent to console
BALATRO_DEBUG="0"

# by vanillyn
EOF

}

mkrepo() {
     local core_repo_file="$REPO_DIR/core.jkrepo"
    if [[ ! -f "$core_repo_file" ]]; then

        local mods_txt_path="$(dirname "$0")/mods.txt"
        if [[ -f "$mods_txt_path" ]]; then
            cat <<EOF >"$core_repo_file"
# REPO_NAME: Official Balatro Mods
# REPO_AUTHOR: vanillyn
# REPO_DESCRIPTION: Core collection of Balatro mods from awesome-balatro.
# REPO_URL: https://raw.githubusercontent.com/vanillyn/balatro-cli/main/mods.txt
# REPO_MOD_COUNT: $(grep -vE '^(#|$)' "$mods_txt_path" | wc -l)

$(cat "$mods_txt_path")
EOF
        else
            echo "Warning: mods.txt not found at $mods_txt_path. Cannot create default core repository."
        fi
    fi

}
# Load config file
load_config() {
    [[ -f "$CONF" ]] && source "$CONF"

    GAME_PATH=$(eval echo "$GAME_PATH")
    DOWNLOAD_DIR=$(eval echo "$DOWNLOAD_DIR")
    MODS_DIR=$(eval echo "$MODS_DIR")
    DISABLED_DIR=$(eval echo "$MODS_DIR/disabled")
    LOVE_BIN=$(eval echo "$LOVE_BIN")
    WINE_BIN=$(eval echo "$WINE_BIN")
    WINEPREFIX=$(eval echo "$WINEPREFIX")
    USER_DIR=$(eval echo "$USER_DIR")
    MODE=$(eval echo "$MODE")
    NOINSTALL=$(eval echo "$NOINSTALL")
    BALATRO_DEBUG=$(eval echo "$BALATRO_DEBUG")

}

# --- Checks
# Package Manager

if [[ -f /etc/arch-release ]]; then
    PKG="pacman -S"
elif [[ -f /etc/debian_version ]]; then
    PKG="apt-get install"
elif [[ -f /etc/redhat-release ]]; then
    PKG="yum install"
elif [[ -f /etc/gentoo-release ]]; then
    PKG="emerge install"
elif [[ -f /etc/SuSE-release ]]; then
    PKG="zypper install"
elif [[ -f /etc/alpine-release ]]; then
    PKG="apk add"
else
    PKG=""
fi

# Necessary packages
check() {
    local b="$1"

    if ! command -v "$b" &>/dev/null; then

        if [[ "$PKG" == "" ]]; then
            echo "Package manager incompatible, install $b manually."
            exit 1
            return
        fi

        read -rp "$b not found. Install it with $PKG? [Y/n] " yn
        if [[ "$yn" == [Yy]* ]]; then
            sudo $PKG "$b"
        else
            echo "Skipping $b install."
        fi
    fi
}

# Balatro install directory
check_install() {
    if [[ -z "$GAME_PATH" ]]; then
        if [[ -d "/usr/share/balatro" ]]; then
            GAME_PATH="/usr/share/balatro"
        elif command -v steam &>/dev/null; then
            if [[ -d "$HOME/.steam/steam/steamapps/common/Balatro" ]]; then
                GAME_PATH="$HOME/.steam/steam/steamapps/common/Balatro"
            fi
        else
            echo "Can't find Balatro directory, please specify with --dir"
        fi
    fi
}

# Git releases
get_releases() {
    local repo="$1"
    local pattern="$2"

    curl -s "https://api.github.com/repos/$repo/releases/latest" |
        grep "browser_download_url" |
        grep "$pattern" |
        cut -d '"' -f 4 |
        head -n 1
}

# --- Command handling
# Handles the flags
flags() {
    while [[ $# -gt 0 ]]; do
        arg="$1"

        if [[ "$arg" == --* ]]; then
            case "$arg" in
            --native) MODE="native" ;;
            --wine) MODE="wine" ;;
            --steam) MODE="steam" ;;
            --noinstall) NOINSTALL=1 ;;
            --dir)
                shift
                BALATRO_DIR="$1"
                ;;
            --mod_dir)
                shift
                MOD_DIR="$1"
                ;;
            --love_dir)
                shift
                LOVE_BIN="$1"
                ;;
            --wine_dir)
                shift
                WINE_BIN="$1"
                ;;
            --wineprefix)
                shift
                WINEPREFIX="$1"
                ;;
            --user_dir)
                shift
                USER_DIR="$1"
                ;;
            --config)
                shift
                CONF="$1"
                ;;
            --debug) BALATRO_DEBUG=1 ;;
            --help) SHOW_HELP=1 ;;
            --version) SHOW_VERSION=1 ;;
            *)
                echo "Unknown flag: $arg"
                exit 1
                ;;
            esac

        elif [[ "$arg" == -* && "$arg" != "--" ]]; then
            flags="${arg:1}"
            i=0
            while [[ $i -lt ${#flags} ]]; do
                flag="${flags:$i:1}"
                ((i++))
                case "$flag" in
                n) MODE="native" ;;
                w) MODE="wine" ;;
                s) MODE="steam" ;;
                h) SHOW_HELP=1 ;;
                v) SHOW_VERSION=1 ;;
                V) BALATRO_DEBUG=1 ;;
                *)
                    echo "Unkown flag: -$flag"
                    exit 1
                    ;;
                esac
            done

        else
            ARGS+=("$arg")
        fi
        shift
    done
}

# Handles commands and subcommands
subcommand() {
    case "$1" in
    launch) launch ;;
    help) help ;;
    version) version ;;
    backup) backup "$2" ;;
    mods)
        shift
        m_command "$@"
        ;;
    install)
        shift
        i_command "$@"
        ;;
    repo)
        shift
        r_command "$@"
        ;;
    *)
        echo "Unknown command: $1"
        help
        ;;
    esac
}

help() {

    echo "balatro-cli: launcher and mod manager for balatro on linux"
    echo "usage: balatro [subcommand] [args...] [--flags]"
    echo ""
    echo "commands:"
    echo "  help           display this help message"
    echo "  launch         launch balatro"
    echo "  backup         backs up balatro save data to a file"
    echo "  mods           manage balatro mods (use 'balatro mods help')"
    echo "  install        install balatro components (use 'balatro install help')"
    echo "  repo           manage mod repositories (use 'balatro repo help')" 
    echo ""
    echo "flags:"
    echo "  -h, --help     display this help message"
    echo "  -v, --version  display version information."
    echo "  -n, --native   launch balatro natively"
    echo "  -w, --wine     launch balatro through wine"
    echo "  -s, --steam    launch balatro through steam/proton"
    echo ""
    echo "  --config       use custom config file"
    echo "  --dir          specify balatro directory"
    echo "  --wineprefix   specify wineprefix"
    echo "  --user_dir     specify save directory"
    echo "  --love_path    location of love executable"
    echo "  --wine_path    location of wine executable"
    echo "  --noinstall    doesn't install mods"
    echo "  --debug        enable debug logging"
    echo ""
}

version() {
    echo "balatro-cli $ver"
    echo "-------"
    echo ""
    echo "mode: $MODE"
    echo ""
    echo "balatro dir: $GAME_PATH"
    echo "mod dir: $MODS_DIR"
    echo ""

    if [[ $MODE == "wine" ]]; then
        if command -v "$WINE_BIN" &>/dev/null; then
            echo "wine version: $($WINE_BIN --version)"
            echo "wineprefix: $WINEPREFIX"
        else
            echo "wine: not found"
        fi
    elif [[ $MODE == "native" ]]; then
        if command -v "$LOVE_BIN" &>/dev/null; then
            echo "love version: $($LOVE_BIN --version 2>/dev/null | head -n1)"
            echo "user dir: $USER_DIR"
        else
            echo "love: not found"
        fi
    fi
}

# Launches Balatro without mods
launch() {
    echo "Starting Balatro [$MODE] (Vanilla)"

    native() {
        if [[ ! -x "$GAME_PATH" ]]; then
            echo "Native Balatro binary not found, please setup with \"balatro install native\""
            exit 1
        fi

        balatro-native
    }

    wine() {
        if [[ ! -f "$GAME_PATH" ]]; then
            echo "Balatro.exe not found in $GAME_PATH. Please install it."
            exit 1
        fi

        if [[ -f "$GAME_PATH/version.dll" ]]; then
            echo "Disabling Lovely"
            mv "$GAME_PATH/version.dll" "$GAME_PATH/version.dll.disabled"
        fi
        WINEPREFIX="$WINEPREFIX" "$WINE_BIN" "$GAME_PATH/Balatro.exe"
    }

    steam() {
        local appid="2379780"

        if command -v steam &>/dev/null; then
            steam -applaunch "$appid"
        else
            echo "Steam not found, please install it here: https://steampowered.com"
            exit 1
        fi
    }

    case "$MODE" in
    native) native ;;
    wine) wine ;;
    steam) steam ;;
    *)
        echo "Can't launch using $MODE"
        exit 1
        ;;
    esac
}

backup() {

    if [[ -z "$1" ]]; then
        local jkr="."
    else
        local jkr="$1"
        mkdir -p "$jkr"
    fi

    echo "Backing up saves in $USER_DIR to $(readlink -f $jkr)"

    local file="$jkr/balatro-save-$(date +%Y-%m-%d).tar.jkr"

    if [[ ! -d "$USER_DIR" ]]; then
        echo "$USER_DIR doesn't exist"
        exit 1
    fi

    tar -czf "$file" -C "$USER_DIR" . || {
        echo "Failed to backup save directory, please back up manually."
        exit 1
    }
    echo "Saves backed up to $file."
}

# --- Handles mod subcommands
m_command() {
    case "$1" in
    launch) m_launch ;;
    install)
        shift
        m_install "$@"
        ;;
    remove)
        shift
        m_remove "$1"
        ;;
    disable)
        shift
        m_disable "$1"
        ;;
    enable)
        shift
        m_enable "$1"
        ;;
    list) m_list ;;
    search)
        shift
        m_search "$1"
        ;;
    *)
        echo "Unknown command: $1"
        m_help
        ;;
    esac
}

m_help() {
    echo "balatro-cli mods: manage balatro mods"
    echo "usage: balatro mods [subcommand] [args...]"
    echo ""
    echo "commands:"
    echo "  launch       launches modded balatro"
    echo "  install      installs specified mod"
    echo "  remove       removes specified mod"
    echo "  disable      temporarily removes mod"
    echo "  enable       enables a disabled mod"
    echo "  search       searches for an available mod"
    echo "  list         lists all installed mods"
    echo ""
}

# Launches Balatro with mods
m_launch() {
   echo "Starting Balatro [$MODE] (Modded)"

    native() {
        check love

        if [[ ! -x "$GAME_PATH" ]]; then
            read -rp "Balatro [$MODE] not installed. Install it? [Y/n] " yn
            if [[ "$yn" == [Yy]* ]]; then
                i_native
                native
            else
                echo "Balatro [$MODE] not installed."
                exit 1
            fi
        else
            mkdir -p "$USER_DIR/Mods"
            mkdir -p "$HOME/.config/love"

            echo "[Lovely] Mod files linked"
            if ldconfig -p | grep -q liblovely; then
                echo "[Lovely] liblovely.so preloaded"
                LD_PRELOAD=liblovely.so balatro-native
            else
                read -rp "Lovely not found. Install Lovely? [Y/n] " yn
                if [[ "$yn" == [Yy]* ]]; then
                    i_lovely
                    native
                else
                    echo "Lovely not installed. Mods will not load."
                    balatro-native
                fi
            fi
        fi
    }

    wine() {
        local dll="$GAME_PATH/version.dll"
        if [[ -f "$GAME_PATH/version.dll.disabled" ]]; then
            echo "Enabling Lovely"
            mv "$GAME_PATH/version.dll.disabled" "$dll"
        elif [[ "$dll" ]]; then
            echo "Lovely enabled"
        fi

        echo "[Lovely] Lovely copied to directory"
        WINEPREFIX="$WINEPREFIX" "$WINE_BIN" "$GAME_PATH/Balatro.exe"
    }
    
    case "$MODE" in
    native) native ;;
    wine) wine ;;
    *) echo "Can't launch using $MODE" ;;
    esac
    
}

r_sync() {
    local aggregated_mods_file="$DOWNLOAD_DIR/mods.txt"
    > "$aggregated_mods_file"

    for repo_file in "$REPO_DIR"/*.jkrepo; do
        if [[ -f "$repo_file" ]]; then
            grep -vE '^(# REPO_NAME:|# REPO_AUTHOR:|# REPO_DESCRIPTION:|# REPO_URL:|# REPO_MOD_COUNT:|^$)' "$repo_file" >> "$aggregated_mods_file"
        fi
    done
}

m_install() {
    [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Entering m_install for mod: $1"
    check git

    local modname="$1"
    local repo_file="$DOWNLOAD_DIR/mods.txt"

    if [[ ! -f "$repo_file" ]]; then
        r_sync
    fi

    if [[ ! -f "$repo_file" ]]; then
        echo "No mod repositories found or synced. Please add a repository first."
        return 1
    fi

    local -a mod_lines
    mapfile -t mod_lines <"$repo_file"

    unset insmod
    declare -g -A insmod
    [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: insmod initialized/cleared. Current keys: ${!insmod[@]}"

    trim() {
        echo "$1" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
    }

    resolve_mod() {
        local in_name="$1"
        in_name=$(echo "$in_name" | tr '[:upper:]' '[:lower:]')

        [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Resolving '$in_name'. Current tracker state: ${!insmod[@]}"

        if [[ -n "${insmod[$in_name]}" ]]; then
            [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Skipping already processed mod: '$in_name' (state: '${insmod[$in_name]}')"
            return
        fi

        local found_entry=""
        local found_name=""
        local found_url=""
        local found_deps=""
        local found_category=""

        for line in "${mod_lines[@]}"; do
            if [[ -z "$line" || "$line" =~ ^# ]]; then
                continue
            fi

            IFS='|' read -r name url deps category <<<"$line"

            name=$(trim "$name")
            url=$(trim "$url")
            deps=$(trim "$deps")
            category=$(trim "$category")

            lname=$(echo "$name" | tr '[:upper:]' '[:lower:]')

            [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG_LOOP: in_name='$in_name', name='$name', lname='$lname', url='$url', deps='$deps', category='$category'"

            if [[ "$lname" == "$in_name" ]]; then
                found_entry="$line"
                found_name="$name"
                found_url="$url"
                found_deps="$deps"
                found_category="$category"
                break
            fi
        done

        if [[ -z "$found_entry" ]]; then
            echo "'$in_name' not found in any active repository."
            [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Exiting resolve_mod for: '$in_name'. Final tracker state: ${!insmod[@]}"
            return 1
        fi

        [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Found match for '$in_name': '$found_name'. Marking as 'processing'."
        insmod[$in_name]="processing"
        [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Tracker state after marking 'processing': ${!insmod[@]}"

        if [[ -n "$found_deps" ]]; then
            IFS=',' read -ra dep_array <<<"$found_deps"
            [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: '$in_name' has dependencies: ${dep_array[*]}"
            for dep in "${dep_array[@]}"; do
                resolve_mod "$dep"
                if [[ $? -ne 0 ]]; then
                    echo "ERROR: Dependency '$dep' failed to install for '$in_name'."
                    return 1
                fi
            done
        fi

        case "$in_name" in
            smod|steamodded)
                i_steammodded
                ;;
            lovely)
                i_lovely
                ;;
            *)
                echo "Installing $found_name [$found_category]"

                local dp="$DOWNLOAD_DIR/$found_name"
                local ip="$MODS_DIR/$found_name"

                mkdir -p "$DOWNLOAD_DIR"

                if [[ -d "$dp/.git" ]]; then
                    echo "Updating $found_name"
                    git -C "$dp" pull || {
                        echo "Update failed for $found_name."
                        return 1
                    }
                else
                    git clone "$found_url" "$dp" || {
                        echo "Download failed for $found_name."
                        return 1
                    }
                fi

                if [[ "$NOINSTALL" != 1 ]]; then
                    mkdir -p "$MODS_DIR"
                    echo "Copying $found_name to "$ip""
                    rsync -a --exclude='.git' "$dp/" "$ip/"
                else
                    echo "Skipping $found_name install."
                fi
                ;;
        esac


        [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Finished processing '$in_name'. Marking as 'installed'."
        insmod[$in_name]="installed"
        [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Tracker state after marking 'installed': ${!insmod[@]}"
        [[ "$BALATRO_DEBUG" == 1 ]] && echo "DEBUG: Exiting resolve_mod for: '$in_name'. Final tracker state: ${!insmod[@]}"
        return 0
    }

    resolve_mod "$modname"
}

m_remove() {
    local modname="$1"
    if [[ -z "$modname" ]]; then
        echo "Usage: balatro mods remove <mod_name>"
        return 1
    fi

    local downloaded_path="$DOWNLOAD_DIR/$modname"
    local installed_path="$MODS_DIR/$modname"

    if [[ -d "$installed_path" ]]; then
        read -rp "Remove '$modname' from your mods directory ($installed_path)? [Y/n] " yn
        if [[ "$yn" == [Yy]* ]]; then
            rm -rf "$installed_path"
            echo "Removed '$modname'."
        else
            echo "Skipping."
        fi
    else
        echo "Mod '$modname' not found."
    fi

    if [[ -d "$downloaded_path" ]]; then
        read -rp "Remove '$modname' from your downloads directory ($downloaded_path)? [Y/n] " yn
        if [[ "$yn" == [Yy]* ]]; then
            rm -rf "$downloaded_path"
            echo "Removed '$modname' from downloads."
        else
            echo "Skipping."
        fi
    else
        echo "Mod '$modname' not found in ($downloaded_path)."
    fi

    if [[ ! -d "$installed_path" ]] && [[ ! -d "$downloaded_path" ]]; then
        echo "Removed '$modname'."
    else
        echo "Removed '$modname' with some paths skipped."
    fi
}

m_disable() {
    local modname="$1"


    mkdir -p "$DISABLED_DIR"

    if [[ -z "$modname" ]]; then
        echo "Usage: balatro mods disable <mod_name>"
        return 1
    fi

    local installed_path="$MODS_DIR/$modname"
    local archive_file="$DISABLED_DIR/${modname}.tar.jkr"

    if [[ ! -d "$installed_path" ]]; then
        echo "Mod '$modname' not found or already disabled."
        return 1
    fi

    mkdir -p "$DISABLED_DIR"
    tar -czf "$archive_file" -C "$(dirname "$installed_path")" "$(basename "$installed_path")" || {
        echo "Failed to create archive for '$modname'."
        return 1
    }

    rm -rf "$installed_path" || {
        echo "Failed to remove original mod directory '$installed_path'."
        return 1
    }

    echo "Disabled '$modname'."
}

m_enable() {
    local modname="$1"
    if [[ -z "$modname" ]]; then
        echo "Usage: balatro mods enable <mod_name>"
        return 1
    fi

    local installed_path="$MODS_DIR/$modname"
    local archive_file="$DISABLED_DIR/${modname}.tar.jkr" 

    if [[ ! -f "$archive_file" ]]; then 
        echo "Mod '$modname' is already enabled."
        return 1
    fi

    tar -xzf "$archive_file" -C "$MODS_DIR" || {
        echo "Failed to extract archive for '$modname'."
        return 1
    }

    rm -f "$archive_file" || {
        echo "Failed to remove archive file '$archive_file'."
        return 1
    }

    echo "Enabled $modname."
}

m_list() {
    echo "Listing installed mods:"
    if [[ -d "$MODS_DIR" ]]; then
        local installed_count=0
        echo "--- enabled:"
        find "$MODS_DIR" -maxdepth 1 -mindepth 1 -type d -not -name "disabled" -printf "%f\n" | sort | while read -r mod; do
            echo "- $mod"
            installed_count=$((installed_count + 1))
        done

        if [[ -d "$DISABLED_DIR" ]]; then
            echo ""
            echo "-- disabled:"
            find "$DISABLED_DIR" -maxdepth 1 -mindepth 1 -type f -name "*.tar.jkr" -printf "%f\n" | sort | while read -r archive_name; do
                local mod=$(basename "$archive_name" .tar.jkr)
                echo "- $mod"
                installed_count=$((installed_count + 1))
            done
        fi

        if [[ "$installed_count" -eq 0 ]]; then
            # echo "No mods found in $MODS_DIR." # may not implement cuz rn its always counting installed_count as 0
            return
        fi
    else
        echo "Mod directory $MODS_DIR does not exist."
    fi
}

m_search() {
    local query="$1"
    local repo_file="$DOWNLOAD_DIR/mods.txt"

    r_sync

    if [[ ! -f "$repo_file" ]]; then
        echo "No mod repositories found or synced. Please add a repository first."
        return 1
    fi

    echo "Searching for '$query'"
    grep -vE '^(# REPO_NAME:|# REPO_AUTHOR:|# REPO_DESCRIPTION:|# REPO_URL:|# REPO_MOD_COUNT:|^$)' "$repo_file" | grep -i "$query" | while IFS='|' read -r name url deps category; do
        name=$(echo "$name" | xargs)
        url=$(echo "$url" | xargs)
        category=$(echo "$category" | xargs)
        echo "Found: $name (Category: $category) - $url"
    done
}

i_command() {
    case "$1" in
    native)
        shift
        i_native "$1"
        ;;
    wine)
        shift
        i_wine "$1"
        ;;
    lovely) i_lovely ;;
    smods | steammodded | smod) i_steammodded ;;
    balamod) i_balamod ;;
    *)
        echo "Unknown command: $1"
        i_help
        ;;
    esac
}

i_help() {
    echo "balatro-cli install: sets up balatro components"
    echo "usage: balatro install [subcommand] [args...]"
    echo ""
    echo "commands:"
    echo "  native       sets up balatro native"
    echo "  wine         sets up a wineprefix"
    echo "  lovely       downloads and installs lovely"
    echo "  smod         downloads and installs steamodded"
    echo "  balamod      downloads and installs balamod"
    echo ""
}

i_native() {
    echo "native"
}

i_wine() { echo "[setting up wine prefix in $1]"; }

i_lovely() {
    echo "Setting up Lovely [$MODE]"
    check curl
    check wget
    check unzip
    check tar

    local repo="ethangreen-dev/lovely-injector"
    local url=""
    local archive=""
    local extract_dir="$DOWNLOAD_DIR/lovely"

    if [[ "$MODE" == "native" ]]; then
        url=$(get_releases "$repo" "lovely-x86_64-unknown-linux-gnu.tar.gz")
        archive="$DOWNLOAD_DIR/lovely-linux.tar.gz"
    else
        url=$(get_releases "$repo" "lovely-x86_64-pc-windows-msvc.zip")
        archive="$DOWNLOAD_DIR/lovely-windows.zip"
    fi

    if [[ -z "$url" ]]; then
        echo "Could not find suitable Lovely [$MODE] release."
        return 1
    fi

    echo "downloading lovely from: $url"
    wget -q -O "$archive" "$url" || {
        echo "Download failed."
        return 1
    }

    echo "extracting to $extract_dir"
    mkdir -p "$extract_dir"
    if [[ "$MODE" == "native" ]]; then
        tar -xf "$archive" -C "$extract_dir" || return 1
        if [[ ! -f "$extract_dir/liblovely.so" ]]; then
            echo "Linux Lovely library file not found"
            return 1
        fi

        echo "Installing liblovely.so to /lib"
        sudo mv "$extract_dir/liblovely.so" /lib/liblovely.so || return 1
        sudo ldconfig
    else
        unzip -o "$archive" -d "$extract_dir" || return 1
        if [[ ! -f "$extract_dir/version.dll" ]]; then
            echo "Windows Lovely library file not found"
            return 1
        fi

        echo "Installing version.dll to $GAME_PATH"
        cp "$extract_dir/version.dll" "$GAME_PATH/version.dll" || return 1
    fi

    echo "Finished installing Lovely [$MODE]"
}

i_steammodded() {
    echo "Setting up SMODS [$MODE]"

    check git

    local repo="https://github.com/Steamodded/smods"
    local mod_dir="$MODS_DIR/smods"

    if [[ -d "$mod_dir/.git" ]]; then
        echo "Updating SMODS [$MODE]"
        git -C "$mod_dir" pull || {
            echo "Update failed."
            return 1
        }
    else
        mkdir -p "$(dirname "$mod_dir")"
        git clone "$repo" "$mod_dir" || {
            echo "Download failed."
            return 1
        }
    fi

    echo "SMODS [$MODE] installed to $mod_dir"
}


# --- Repository commands
r_command() {
    case "$1" in
    add)
        shift
        r_add "$@"
        ;;
    delete)
        shift
        r_delete "$1"
        ;;
    list) r_list ;;
    sync) r_sync ;;
    *)
        echo "Unknown command: $1"
        r_help
        ;;
    esac
}

r_help() {
    echo "balatro-cli repo: manage mod repositories"
    echo "usage: balatro repo [subcommand] [args...]"
    echo ""
    echo "commands:"
    echo "  add <name> <url>   add a new mod repository from a URL"
    echo "  delete <name>      delete an existing mod repository"
    echo "  list               list all active mod repositories"
    echo "  sync               re-sync all mod data from active repositories"
    echo ""
}

r_add() {
    local repo_name="$1"
    local repo_url="$2"

    if [[ -z "$repo_name" || -z "$repo_url" ]]; then
        echo "Usage: balatro repo add <name> <url>"
        return 1
    fi

    local repo_file="$REPO_DIR/${repo_name}.jkrepo"

    if [[ -f "$repo_file" ]]; then
        echo "Repository '$repo_name' already exists. Use 'repo delete' first if you want to replace it."
        return 1
    fi

    check curl
    check wget

    echo "Downloading repository from $repo_url..."
    if ! wget -q -O "$repo_file.tmp" "$repo_url"; then
        echo "Failed to download repository from $repo_url."
        rm -f "$repo_file.tmp"
        return 1
    fi

    if ! grep -q '|' "$repo_file.tmp"; then
        echo "Downloaded file does not appear to be a valid mod repository format (missing '|' delimiters)."
        rm -f "$repo_file.tmp"
        return 1
    fi

    local downloaded_content=$(cat "$repo_file.tmp")
    local extracted_name=$(echo "$downloaded_content" | grep -m 1 '^# REPO_NAME:' | cut -d ':' -f 2- | xargs)
    local extracted_author=$(echo "$downloaded_content" | grep -m 1 '^# REPO_AUTHOR:' | cut -d ':' -f 2- | xargs)
    local extracted_desc=$(echo "$downloaded_content" | grep -m 1 '^# REPO_DESCRIPTION:' | cut -d ':' -f 2- | xargs)

    : "${extracted_name:=$repo_name}"
    : "${extracted_author:=Unknown}"
    : "${extracted_desc:=No description provided.}"

    echo "# REPO_NAME: $extracted_name" > "$repo_file"
    echo "# REPO_AUTHOR: $extracted_author" >> "$repo_file"
    echo "# REPO_DESCRIPTION: $extracted_desc" >> "$repo_file"
    echo "# REPO_URL: $repo_url" >> "$repo_file"
    local mod_count=$(echo "$downloaded_content" | grep -vE '^(#|$)' | wc -l)
    echo "# REPO_MOD_COUNT: $mod_count" >> "$repo_file"
    echo "$downloaded_content" >> "$repo_file"

    rm -f "$repo_file.tmp"

    echo "Repository '$repo_name' added successfully."
    r_sync
}

r_delete() {
    local repo_name="$1"

    if [[ -z "$repo_name" ]]; then
        echo "Usage: balatro repo delete <name>"
        return 1
    fi

    local repo_file="$REPO_DIR/${repo_name}.jkrepo"

    if [[ ! -f "$repo_file" ]]; then
        echo "Repository '$repo_name' not found."
        return 1
    fi

    read -rp "Are you sure you want to delete repository '$repo_name'? [Y/n] " yn
    if [[ "$yn" == [Yy]* ]]; then
        rm -f "$repo_file"
        echo "Repository '$repo_name' deleted."
        r_sync
    else
        echo "Deletion cancelled."
    fi
}

r_list() {
    echo "Listing active mod repositories:"
    local found_repos=0
    for repo_file in "$REPO_DIR"/*.jkrepo; do
        if [[ -f "$repo_file" ]]; then
            found_repos=$((found_repos + 1))
            local name=$(grep -m 1 '^# REPO_NAME:' "$repo_file" | cut -d ':' -f 2- | xargs)
            local author=$(grep -m 1 '^# REPO_AUTHOR:' "$repo_file" | cut -d ':' -f 2- | xargs)
            local desc=$(grep -m 1 '^# REPO_DESCRIPTION:' "$repo_file" | cut -d ':' -f 2- | xargs)
            local mod_count=$(grep -m 1 '^# REPO_MOD_COUNT:' "$repo_file" | cut -d ':' -f 2- | xargs)

            echo "------------------------------------"
            echo "Name: ${name:-$(basename "$repo_file" .jkrepo)} (${mod_count:-Unknown} mods)"
            echo "Author: ${author:-Unknown}"
            echo "Description: ${desc:-No description provided.}"
        fi
    done

    if [[ "$found_repos" -eq 0 ]]; then
        echo "No repositories found. Add one with 'balatro repo add'."
    else
        echo "------------------------------------"
    fi
}


# --- Locks script        so nothing breaks
lock() {

    echo $$ >"$LOCKFILE"

    cleanup() {
        rm -f "$LOCKFILE"
        echo "cleaned up lockfile"
        exit
    }

    trap cleanup INT TERM EXIT
}

# ----------- Main function
main() {
    lock() [[ -f "$CONF" ]] || mkconf
    mkrepo
    load_config

    flags "$@"

    [[ "$SHOW_HELP" == 1 ]] && help && exit 0
    [[ "$SHOW_VERSION" == 1 ]] && version && exit 0

    if [[ ${#ARGS[@]} -gt 0 ]]; then
        subcommand "${ARGS[@]}"
        exit 0

    else
        help
        exit 0
    fi
}

main "$@"
